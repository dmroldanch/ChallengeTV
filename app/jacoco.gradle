apply plugin: 'jacoco'

jacoco {
    toolVersion = "0.8.8"
}

tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
}

// Common config
def fileFilter = [
        '**/R.class', '**/R$*.class',
        '**/BuildConfig.*',
        '**/Manifest*.*',
        '**/*Test*.*',
        'android/**/*.*'
]

// Rutas para AGP moderno (Java + Kotlin)
def javaDebugTree = fileTree(
        dir: "${buildDir}/intermediates/javac/debug/classes",
        excludes: fileFilter
)
def kotlinDebugTree = fileTree(
        dir: "${buildDir}/classes/kotlin/debug",
        excludes: fileFilter
)
def mainSrc = "${project.projectDir}/src/main/java"

def execData = fileTree(dir: buildDir, includes: [
    'jacoco/*.exec',
    'jacoco/*.ec',
    '**/testDebugUnitTest.exec',
    '**/*.ec'
])

/**
 * Reporte Jacoco genérico.
 */
task jacocoTestReport(type: JacocoReport, dependsOn: 'testDebugUnitTest') {
    group = "verification"
    description = "Generate Jacoco coverage report for debug unit tests"

    reports {
        xml.required = true
        html.required = true
    }

    sourceDirectories.setFrom(files(mainSrc))
    classDirectories.setFrom(files(javaDebugTree, kotlinDebugTree))
    executionData.setFrom(execData)
}

/**
 * Verificación de cobertura mínima (50%).
 */
task jacocoTestCoverageVerification(type: JacocoCoverageVerification, dependsOn: 'jacocoTestReport') {
    group = "verification"
    description = "Verifies that line coverage is above the minimum threshold"

    executionData.setFrom(execData)

    sourceDirectories.setFrom(files(mainSrc))
    classDirectories.setFrom(files(javaDebugTree, kotlinDebugTree))

    violationRules {
        rule {
            element = 'BUNDLE'
            limit {
                counter = 'LINE'
                // OJO: sin guion bajo
                value   = 'COVEREDRATIO'
                minimum = 0.5   // 50% mínimo
            }
        }
    }
}


/**
 * Extra task to PRINT coverage in the console.
 * It searches any Jacoco XML report under build/ and parses it with regex (no XML parser).
 */
task printJacocoCoverage(dependsOn: 'jacocoTestReport') {
    group = "verification"
    description = "Prints overall line coverage from any Jacoco XML report"

    doLast {
        def buildDirFile = file("${buildDir}")
        if (!buildDirFile.exists()) {
            logger.lifecycle("Build directory not found: $buildDirFile")
            return
        }

        // Look for potential Jacoco XML reports
        def xmlFiles = fileTree(dir: buildDirFile, includes: [
                '**/jacoco*.xml',
                '**/*TestReport*.xml',
                '**/jacocoTestReport.xml'
        ]).files

        if (xmlFiles.isEmpty()) {
            logger.lifecycle("No Jacoco XML report found under: $buildDirFile")
            return
        }

        def reportFile = xmlFiles.first()
        logger.lifecycle("Using Jacoco XML report: $reportFile")

        String text = reportFile.getText('UTF-8')

        // <counter type="LINE" missed="X" covered="Y" .../>
        def matcher = text =~ /<counter[^>]*type="LINE"[^>]*missed="(\d+)"[^>]*covered="(\d+)"[^>]*\/>/

        if (!matcher.find()) {
            logger.lifecycle("No LINE counters found in Jacoco report.")
            return
        }

        int missedTotal = 0
        int coveredTotal = 0

        matcher.each { full, missedStr, coveredStr ->
            missedTotal += missedStr.toInteger()
            coveredTotal += coveredStr.toInteger()
        }

        int total = missedTotal + coveredTotal
        double coverage = total > 0 ? (coveredTotal * 100.0 / total) : 0.0
        double missing  = 100.0 - coverage

        logger.lifecycle(String.format(
                "=> Line coverage: %.2f%% (%d / %d lines covered)",
                coverage, coveredTotal, total
        ))
        logger.lifecycle(String.format(
                "=> Missing coverage: %.2f%% (%d lines not covered)",
                missing, missedTotal
        ))
    }
}
